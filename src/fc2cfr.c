#include <stdio.h>

#include "fidoconf/fidoconf.h"
#include "fidoconf/common.h"

int writeArea(FILE *f, s_area *area, char netMail) {
   switch (area->msgbType) {
      
      case (MSGTYPE_SQUISH): fprintf(f, "NETSQUISH ");
                             break;
      
      case (MSGTYPE_SDM):    fprintf(f, "NETMAIL ");
                             break;

      case (MSGTYPE_JAM):    fprintf(f, "NETJAM ");
                             break;

      default:               return -1;
   }

   if (netMail != 1) return -1;

   fprintf(f, "%s\n", area->fileName);

   return 0;
}

static void fc_print_address(FILE *f, s_addr *paddr)
{
    fprintf (f, "%u:%u/%u.%u", paddr->zone, paddr->net,
             paddr->node, paddr->point);
    if (paddr->domain != NULL && *(paddr->domain))
    {
        fprintf (f, "@%s", paddr->domain);
    }
}

#define ALL 0
#define RFILE 1
#define MAIL 2

#define ROUTE 0
#define DIRECT 3
#define BOSS  6
#define NOPACK 9

const char *commands[] = {
    "ROUTE", "ROUTE-FILE", "ROUTE-MAIL",
    "DIRECT-TO", "DIRECT-MAIL", "DIRECT-FILES",
    "ROUTE-BOSS", "ROUTE-BOSS-MAIL", "ROUTE-BOSS-FILES",
    "NOPACK", "NOPACK-MAIL", "NOPACK-FILES"
};

static void fc_convert_route(FILE *f, s_route *route, int what)
{
    int mode = ROUTE;
    static s_route *lastroute = NULL;

    if (lastroute == NULL || route->flavour != lastroute->flavour ||
        route->enc != lastroute->enc ||
        (route->target == NULL && lastroute->target != NULL) ||
        (route->target != NULL && lastroute->target == NULL) ||
        (route->target != NULL && lastroute->target != NULL &&
         addrComp((route->target->hisAka), (lastroute->target->hisAka))) ||
        (route->target == NULL && lastroute->target == NULL &&
         route->routeVia != lastroute->routeVia))
    {
        fprintf(f, "\n");
        if (route->target == NULL)
        {
            switch (route->routeVia)
            {
            case route_zero:
            case nopack:
                mode = NOPACK;
                break;
                
            case noroute:
                mode = DIRECT;
                break;
                
            case boss:
                mode = BOSS;
                break;
                
            case host:
            case hub:
            case route_extern:
                fprintf (stderr, "Host, Hub and External routing is not supported "
                         "by cfroute.\n");
                abort();
            }
        }
        
        fprintf(f, "%s ", commands[mode + what]);
        
        if (route->flavour != normal)
        {
            switch (route->flavour)
            {
            case hold:      fprintf(f, "HOLD "); break;
            case crash:     fprintf(f, "CRASH "); break;
            case direct:    fprintf(f, "DIRECT "); break;
            case immediate: fprintf(f, "IMMEDIATE "); break;
            default:        fprintf(stderr, "unknwon flavour\n"); abort();
            }
        }
        
        if (route->target != NULL)
        {
            fc_print_address(f, &(route->target->hisAka));
            fprintf(f, " ");
        }
    }

    fprintf(f, "%s ", route->pattern);

    lastroute = route;
}

int generateCfrouteConfig(s_fidoconfig *config, char *fileName)
{
  FILE *f;
  int  i;
  s_area *area;
  
  f = fopen(fileName, "w");
  if (f != NULL)
    {
        fprintf (f,";;CFROUTE configuration file automatically generated by fconf2cfr\n");
        fprintf (f,"EOLENDSCOMMAND  ; end of line terminates any comments. This avoids ambiguities.\n");
        fprintf (f,"TOPDOWN         ; the FIRST matching route is taken - this is the same logic\n");
        fprintf (f,"                ; which hpt is using\n");
        fprintf (f,";VIABOSSHOLD\n");
        fprintf (f,";VIABOSSDIRECT  ; we do NOT set VIABOSSDIRECT to mimic hpt's behaviour, but I\n");
        fprintf (f,"                ; strongly recommend that you DO set VIABOSSDIRECT. Please\n"); 
        fprintf (f,"                ; do read the cfroute documentation.\n");
        fprintf (f,"NODOMAINDIR     ; hpt and fidoconfig do not support domain outbound.\n");
        fprintf (f,";KILLINTRANSIT\n");

        fprintf (f,"\n");

        fprintf (f,"LOG %scfroute.log\n", config->logFileDir);

        fprintf (f,"OUTBOUND %s\n", config->outbound);
        if (config->outtab != NULL)
            fprintf (f,"RECODE %s\n", config->outtab);
        if (config->lockfile != NULL)
            fprintf (f, "CHECKFILE %s\n", config->lockfile);
      
        fprintf (f, "\n");

        fprintf (f, "MAIN ");
        fc_print_address(f,config->addr);
        fprintf (f, "\n");
              
        for (i=1; i<config->addrCount; i++)
        {
            fprintf(f, "AKA  ");
            fc_print_address(f,config->addr + i);
            fprintf(f, "\n");
        }

        fprintf (f, "\n");

        for (i=0; i<config->linkCount; i++)
        {
            if (config->links[i].pktPwd != NULL)
            {
                fprintf(f, "PASSWORD %s ", config->links[i].pktPwd);
                fc_print_address(f,&(config->links[i].hisAka));
                fprintf(f, "\n");
            }
            else if (config->links[i].defaultPwd != NULL)
            {
                fprintf(f, "PASSWORD %s ", config->links[i].defaultPwd);
                fc_print_address(f,&(config->links[i].hisAka));
                fprintf(f, "\n");
            }

        }

        fprintf (f, "\n");
        
        for (i=0; i<config->netMailAreaCount; i++) {
            writeArea(f, &(config->netMailAreas[i]), 1);
        }


        for (i = 0; i < config->routeFileCount; i++)
        {
            fc_convert_route(f, config->routeFile + i, RFILE);
        }
        for (i = 0; i < config->routeMailCount; i++)
        {
            fc_convert_route(f, config->routeMail + i, MAIL);
        }
        for (i = 0; i < config->routeCount; i++)
        {
            fc_convert_route(f, config->route + i, ALL);
        }

        fprintf (f, "\n");

        return 0;
    } else printf("Could not write %s\n", fileName);
    
    return 1;
}

int main (int argc, char *argv[])
{
    s_fidoconfig *config;
    
    printf("fconf2cfr\n");
    printf("---------\n");
    if (argc < 2)
    {
        printf("\nUsage:\n");
        printf("   fc2cfr <cfrouteConfigFileName>\n");
        printf("\nExample:\n");
        printf("   fc2cfr cfroute.cfg\n\n");
        return 1;
    }
    
    printf("Generating Config-file %s\n", argv[1]);
    
    config = readConfig(NULL);
    if (config!= NULL)
    {
        generateCfrouteConfig(config, argv[1]);
        disposeConfig(config);
        return 0;
    }
    
    return 1;
}
